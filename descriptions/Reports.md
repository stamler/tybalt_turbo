# Reports

## Payroll Report By Week

### time component

The current version of tybalt uses payrollReport-FoldedAmendments.sql to populate the table for the week. The only argument is a text string in format `YYYY-MM-DD` which is expected to be a Saturday.

```sql
/* This SQL is designed to exactly replicate the CSV report generated by
 generatePayrollCSV(). Testing has been done using a jupyter notebook in the
 frontend/src/notebooks directory to ensure that the results are identical. The
 only difference is as follows:
 
 For pay periods when a payroll report entry for a staff member includes any
 amendments, the SQL version of the report names the amender as the manager
 rather than the manager who approved the timesheets. The rationale for this is
 that the amender had reason to modify the original data.
 
This is a different behaviour than the pre-SQL reports in which the approving
manager was always listed as the manager regardless of the presence of
amendments.
 
I will be removing the non-SQL reports in version 0.11.0 so the SQL behaviour
will be the only behaviour in Tybalt payroll reports.
 */

/* The outside query does math for some additional columns and sorts and aliases
 them for presentation to the user */
SELECT payrollId,
  DATE_FORMAT(weekEnding,"%Y %b %d") weekEnding,
  surname,
  givenName,
  CONCAT(givenName, " ", surname) name,
  manager,
  IFNULL(mealsSum,0) meals,
  IFNULL(daysOffRotation, 0) "days off rotation",
  IFNULL(hoursWorked, 0) "hours worked",
  salaryHoursOver44,
  IFNULL(adjustedHoursWorked, 0) adjustedHoursWorked,
  totalOvertimeHours "total overtime hours",
  CASE
    WHEN salary = FALSE THEN CASE
      WHEN overtimeHoursToBank > 0 THEN totalOvertimeHours - overtimeHoursToBank
      ELSE totalOvertimeHours
    END
    ELSE 0
  END "overtime hours to pay",
  Bereavement,
  Stat "Stat Holiday",
  PPTO,
  Sick,
  Vacation,
  IFNULL(overtimeHoursToBank, 0) "overtime hours to bank",
  IFNULL(overtimePayoutRequested, 0) "Overtime Payout Requested",
  IFNULL(hasAmendmentsForWeeksEnding, "") hasAmendmentsForWeeksEnding,
  salary
FROM (
    /* This mid-level subquery does math that is simpler at this level because
     it can use aliases created in the inside query rather than recreating the
     math again */
    SELECT *,
      CASE
        WHEN salary = TRUE
        AND hoursWorked > 44 THEN hoursWorked - 44
        ELSE 0
      END AS salaryHoursOver44,
      CASE
        WHEN salary = TRUE THEN CASE
          WHEN hoursWorked + IFNULL(Stat,0) + IFNULL(Bereavement,0) > workWeekHours THEN workWeekHours - IFNULL(Stat,0) - IFNULL(Bereavement,0)
          ELSE hoursWorked
        END
        ELSE CASE
          WHEN hoursWorked > 44 THEN 44
          ELSE hoursWorked
        END
      END AS adjustedHoursWorked,
      CASE
        WHEN salary = FALSE
        AND hoursWorked > 44 THEN hoursWorked - 44
        ELSE 0
      END AS totalOvertimeHours
    FROM (
        /* The inside query, with an ALIAS of BASE, is grouped by primaryUid,
         which is an alias of uid created because the immediate subquery has two
         columns called uid. Each SUM column wraps a CASE statement which pivots
         the single timetype column into a column for each of the corresonding
         timetype values so that we can individually SUM them */
        SELECT *,
          SUM(meals) mealsSum,
          SUM(
            CASE
              WHEN timetype = "OR" THEN 1
            END
          ) daysOffRotation,
          SUM(
            CASE
              WHEN timetype IN ("R", "RT") THEN IFNULL(hours, 0) + IFNULL(jobHours, 0)
            END
          ) hoursWorked,
          SUM(
            CASE
              WHEN timetype = "OB" THEN hours
            END
          ) Bereavement,
          SUM(
            CASE
              WHEN timetype = "OH" THEN hours
            END
          ) Stat,
          SUM(
            CASE
              WHEN timetype = "OP" THEN hours
            END
          ) PPTO,
          SUM(
            CASE
              WHEN timetype = "OS" THEN hours
            END
          ) Sick,
          SUM(
            CASE
              WHEN timetype = "OV" THEN hours
            END
          ) Vacation,
          SUM(
            CASE
              WHEN timetype = "RB" THEN hours
            END
          ) overtimeHoursToBank,
          SUM(payoutRequestAmount) overtimePayoutRequested
        FROM (
            /* This subquery is made of two joined subqueries. The LEFT is
             specified columns from all TimeAmendments rows with the given
             weekEnding. The RIGHT is a JSON array of all of the weekEndings for
             each UID where the committedWeekEnding is equal to the provided
             weekEnding value. The RIGHT is created with a subquery on
             TimeAmendments and is created because JSON_ARRAYAGG() has no
             ability to have DISTINCT inside it */
            SELECT *
            FROM (
                SELECT payrollId, -- MUST JOIN TO admin_profiles on uid = id to get payroll_id
                  workWeekHours,  -- MUST JOIN TO admin_profiles on uid = id to get work_week_hours
                  committedWeekEnding weekEnding, -- committed_week_ending on time_amendments
                  surname, -- MUST JOIN TO profiles on uid = uid to get surname
                  givenName, -- MUST JOIN TO profiles on uid = uid to get given_name
                  commitName manager, -- MUST JOIN TO profiles via users on the commiter field to create commit_name
                  mealsHours meals, -- meals_hours
                  payoutRequestAmount, -- payout_request_amount
                  committedWeekEnding, -- committed_week_ending
                  salary, -- MUST JOIN TO admin_profiles on uid = id to get salary bool
                  uid primaryUid,
                  timetype, -- MUST JOIN TO time_types on time_type = id to get code
                  hours, -- 0 if job is present
                  jobHours -- hours if job is present
                FROM TimeAmendments
                WHERE committedWeekEnding = ?
              ) X
              LEFT OUTER JOIN (
                -- The purpose of the Y table is to return a JSON list of dates 
                -- (week endings) for which a time_amendments record has been
                -- folded into the final output row for a given uid. In other
                -- words, the column hasAmendmentsForWeeksEnding will be empty
                -- unless for this week, the user has amendments included in 
                -- their totals. In such a case this would be a list of one or
                -- more date strings representing week endings.
                SELECT uid,
                  JSON_ARRAYAGG(weekEnding) hasAmendmentsForWeeksEnding -- MUST BE json_group_array() in SQLite
                FROM (
                    SELECT DISTINCT uid,
                      weekEnding
                    FROM TimeAmendments
                    WHERE committedWeekEnding = ?
                  ) Y
                GROUP BY uid
              ) Y ON X.primaryUid = Y.uid
              /* By default, duplicate rows are removed in MySQL (UNION
               DISTINCT). Here we use UNION ALL so that the totals include every
               TimeEntry and Amendment entered */
            UNION ALL
            /* Regular TimeEntries joined with the corresponding TimeSheets with
             columns matching the previous query. Uses the weekEnding value to
             get only the TimeEntries from a particular week. NULL columns are
             created for committedWeekEnding, the second uid column, and
             hasAmendmentsForWeekEnding since these columns only appear in the
             first subquery of the UNION */
            SELECT payrollId,
              workWeekHours,
              weekEnding,
              surname,
              givenName,
              managerName,
              mealsHours,
              payoutRequestAmount,
              NULL,
              salary,
              TimeEntries.uid,
              timetype,
              hours,
              jobHours,
              NULL,
              NULL
            FROM TimeEntries
              LEFT OUTER JOIN TimeSheets ON TimeEntries.tsid = TimeSheets.id
            WHERE weekEnding = ?
          ) BASE
        GROUP BY primaryUid
      ) MIDDLE
  ) FINAL ORDER BY LENGTH(payrollId), payrollId;
```

### expense component

The current version of tybalt uses payablesPayrollCSV.sql to populate the table for the week. The only argument is a text string in format `YYYY-MM-DD` which is expected to be a Saturday.

```sql
/* A query to replace generatePayablesCSV() in the old backend. This is the
highest-level query that outputs the CSV and relies on views with manipulate the
underlying data */
SELECT payrollId,
  paymentType "Acct/Visa/Exp",
  job "Job #",
  client Client,
  jobDescription "Job Description",
  division "Div",
  DAYOFMONTH(e.date) Date,
  DATE_FORMAT(e.date, "%b") Month,
  YEAR(e.date) Year,
  mergedTotal - ROUND(mergedTotal * 13 / 113, 2) calculatedSubtotal,
  ROUND(mergedTotal * 13 / 113, 2) calculatedOntarioHST,
  mergedTotal Total,
  po "PO#",
  mergedDescription Description,
  vendorName Company,
  displayName Employee,
  managerName "Approved By"
FROM ExpensePayablesShell e
WHERE e.payPeriodEnding = ?
ORDER BY e.date
```

This depends on ExpensePayablesShell

```sql
/* This query joins the Expenses with their calculated values for allowances and
mileage. It is used as the source for the payables CSV. The only remaining task
is to filter the dates, calculate the taxes, and rename columns to finish the
CSV report */
CREATE VIEW ExpensePayablesShell AS
SELECT e.*, 
  CASE
    WHEN paymentType = "Mileage" THEN m.mileageTotal
    WHEN paymentType = "Allowance" OR paymentType = "Meals" THEN a.allowanceTotal
    ELSE total
  END mergedTotal,
  CASE
    WHEN paymentType = "Allowance" OR paymentType = "Meals" THEN a.allowanceDescription
    ELSE description
  END mergedDescription
FROM Expenses e
LEFT JOIN ExpenseMileageTotals m ON m.id = e.id
LEFT JOIN ExpenseAllowanceTotals a ON a.id = e.id
```

Which in turn depends on ExpenseMileageTotals

```sql
/* This query calculates the mileageTotal, that is the amount of each expense in
 dollars based on the distance claimed and the mileage tier for each claim. IF
 the claim spans two mileage tiers, this is accounted for and the calculation is
 performed piecewise for each tier. This result can be LEFT JOINed to Expenses ON
 id = id. */
CREATE VIEW ExpenseMileageTotals AS (
  WITH no_tiers AS (
    SELECT e.id,
      e.surname,
      e.date,
      r.date reset_mileage_date,
      distance,
      sum(distance) over (
        partition by uid,
        r.date
        order by date
      ) as cumulative_distance,
      m.id mileageRateGroupId
    FROM Expenses e
      INNER JOIN MileageResetDates r ON r.date = (
        SELECT MAX(r2.date)
        FROM MileageResetDates r2
        WHERE r2.date <= e.date
      )
      LEFT JOIN MileageRateGroups m ON m.effective_date = (
        SELECT MAX(m2.effective_date)
        FROM MileageRateGroups m2
        WHERE m2.effective_date <= e.date
      )
    WHERE e.paymentType = "Mileage"
    ORDER BY uid,
      date
  )
  SELECT no_tiers.*,
    lt.rate lower_rate,
    ut.lower_bound lower_rate_cutoff,
    ut.rate upper_rate,
    IF(lt.rate = ut.rate, NULL, TRUE) multi_tier,
    IF(
      lt.rate = ut.rate,
      lt.rate * distance,
      (cumulative_distance - ut.lower_bound) * ut.rate + (ut.lower_bound + distance - cumulative_distance) * lt.rate
    ) mileageTotal
  FROM no_tiers
    LEFT JOIN MileageTiers lt ON lt.id = (
      SELECT id
      FROM (
          SELECT *,
            ROW_NUMBER() OVER(
              ORDER BY lower_bound DESC
            ) rn
          FROM MileageTiers t2
          WHERE t2.lower_bound <= (no_tiers.cumulative_distance - no_tiers.distance)
            AND t2.rate_group_id = no_tiers.mileageRateGroupId
        ) lower_tier_candidates
      WHERE rn = 1
    )
    LEFT JOIN MileageTiers ut ON ut.id = (
      SELECT id
      FROM (
          SELECT *,
            ROW_NUMBER() OVER(
              ORDER BY lower_bound DESC
            ) rn
          FROM MileageTiers t3
          WHERE t3.lower_bound <= no_tiers.cumulative_distance
            AND t3.rate_group_id = no_tiers.mileageRateGroupId
        ) upper_tier_candidates
      WHERE rn = 1
    )
)
```

And ExpenseAllowanceTotals

```sql
/* This view calculates the allowanceTotal, that is the amount of each expense
in dollars based on the allowances claimed. This result can be LEFT JOINed to
Expenses ON id = id.*/
CREATE VIEW `ExpenseAllowanceTotals`
AS SELECT
   e.id AS id,
   r.effective_date AS allowance_rates_effective_date,
   r.breakfast_rate AS breakfast_rate,
   r.lunch_rate AS lunch_rate,
   r.dinner_rate AS dinner_rate,
   r.lodging_rate AS lodging_rate,
   (e.breakfast * r.breakfast_rate) + (e.lunch * r.lunch_rate) + (e.dinner * r.dinner_rate) + (e.lodging * r.lodging_rate) AS allowanceTotal,
   CONCAT(
    IF(e.breakfast, "Breakfast ", ""),
    IF(e.lunch, "Lunch ", ""),
    IF(e.dinner, "Dinner ", ""),
    IF(e.lodging, "Lodging ", "")
   ) allowanceDescription
FROM (Expenses e LEFT JOIN AllowanceRates r ON ((r.effective_date = (SELECT MAX(i.effective_date) FROM AllowanceRates i WHERE (i.effective_date <= e.date)))))
WHERE e.paymentType = 'Allowance' OR e.paymentType = 'Meals';
```
